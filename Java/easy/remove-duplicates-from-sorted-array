已知长度为n 的线性表L采用顺序存储结构，并且数据元素按值大小非递减排列。写一算法，删除线性表中值相同的多余元素。

【输入形式】
线性表的长度n，线性表L的信息
【输出形式】
删除相同的多余元素后的线性表
【样例输入】
5
1 1 2 2 3
【样例输出】
1 2 3
#include <iostream>
using namespace std;
void remove(int L[],int &n){
	if(n<=1){
		return;
	}
	int i=0;
	for(int j=1;j<n;j++){
		if(L[j]!=L[i]){
			i++;
			L[i]=L[j];
		}
	}
	n=i+1;
}
int main(){
	int n;
	cin>>n;
	int *L=new int[n];
	for(int i=0;i<n;i++){
		cin>>L[i];//TODO
	}
	remove(L,n);
	
	for(int i=0;i<n;i++){
		cout<<L[i];
		if(i<n-1){
			cout<<" ";
		}
	}
	cout<<endl;
	delete[] L;
	return 0;
}

双指针思想的来源
慢指针(i)：指向当前"有效结果"的最后一个位置
快指针(j)：遍历整个数组，寻找新的不重复元素

3. 算法演进思考
初始想法：可能需要复杂的比较和移动

cpp
// 朴素方法：发现重复就整体前移 - O(n²)
for (int i = 0; i < n-1; i++) {
    while (i+1 < n && L[i] == L[i+1]) {
        // 把后面所有元素前移 - 效率低
        for (int k = i+1; k < n-1; k++) {
            L[k] = L[k+1];
        }
        n--;
    }
}
优化思路：既然重复元素是相邻的，为什么不一次遍历就完成？

4. 双指针的诞生
想象两个"光标"在数组上移动：

j 负责探索新元素

i 负责记录有效结果

关键观察：

当 L[j] == L[i]：说明是重复元素，跳过

当 L[j] != L[i]：说明找到了新元素，应该放到结果中

5. 具体执行逻辑
text
初始： [1, 1, 2, 2, 3]
        i  j

步骤1：j=1, L[1]=1 == L[0]=1 → 跳过
        i     j

步骤2：j=2, L[2]=2 != L[0]=1 → i移到1, L[1]=2
           i     j

步骤3：j=3, L[3]=2 == L[1]=2 → 跳过
           i        j

步骤4：j=4, L[4]=3 != L[1]=2 → i移到2, L[2]=3
              i        j

结果： [1, 2, 3], n=3
为什么这个方法优雅？
时间复杂度 O(n)：只需一次遍历

空间复杂度 O(1)：原地操作，不需要额外空间

逻辑清晰：双指针各司其职

充分利用前提条件：有序性让问题简化

通用思维模式
这种"双指针"或"快慢指针"技巧在很多场景都适用：
有序数组去重、合并有序数组、链表操作、滑动窗口问题

核心思想：通过维护不同的指针来分离"处理"和"探索"的功能，从而在一次遍历中完成复杂操作。
